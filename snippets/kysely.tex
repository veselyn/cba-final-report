% Migrations
\begin{minted}[linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{typescript}
import { sql, type Kysely } from "kysely";
import { DB } from "@/app/database";

export async function up(db: Kysely<DB>): Promise<void> {
  await db.schema
    .createTable("users")
    .addColumn("id", "serial", (col) => col.primaryKey())
    .addColumn("email", "text", (col) => col.unique().notNull())
    .addColumn("password", "text", (col) => col.notNull())
    .addColumn("created_at", "timestamptz", (col) =>
      col.notNull().defaultTo(sql`NOW()`),
    )
    .addColumn("updated_at", "timestamptz", (col) =>
      col.notNull().defaultTo(sql`NOW()`),
    )
    .execute();
}

export async function down(db: Kysely<DB>): Promise<void> {
  await db.schema.dropTable("users").execute();
}
\end{minted}

% Seeds

\begin{minted}[linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{typescript}
import { DB } from "@/app/database";
import type { Kysely } from "kysely";
import { hash } from "bcrypt";

type User = {
  email: string;
  password: string;
  birthdate: Date;
  lastName: string;
  timezone: string;
  firstName: string;
  description: string;
  originCountry: string;
};

export async function seed(db: Kysely<DB>): Promise<void> {
  const users: User[] = [
    {
      email: "veselinivanov@seed.com",
      password: "veselinivanov",
      birthdate: new Date(Date.UTC(1998, 5, 25)),
      lastName: "Ivanov",
      timezone: "Europe/Copenhagen",
      firstName: "Veselin",
      description:
        "This is Veselin's description. It is a longer description. Yes, a very very very very very long description!!! Even longer than I was expecting it to have to be. How long does it have to be... for god's sake.",
      originCountry: "Bulgaria",
    },
    {
      email: "juaninicolai@seed.com",
      password: "juaninicolai",
      birthdate: new Date(Date.UTC(1997, 4, 24)),
      lastName: "Nicolai",
      timezone: "America/Argentina/Cordoba",
      firstName: "Juani",
      description: "This is Juan's description",
      originCountry: "Argentina",
    },
  ];

  for (const user of users) {
    const userIdPromise = db
      .insertInto("users")
      .values({
        email: user.email,
        password: await hash(user.password, 1),
      })
      .returning("id")
      .executeTakeFirstOrThrow()
      .then(({ id }) => id);

    const timezoneIdPromise = db
      .selectFrom("timezones")
      .select("id")
      .where("timezone", "=", user.timezone)
      .executeTakeFirstOrThrow()
      .then(({ id }) => id);

    const countryIdPromise = db
      .selectFrom("countries")
      .select("id")
      .where("country", "=", user.originCountry)
      .executeTakeFirstOrThrow()
      .then(({ id }) => id);

    const userId = await userIdPromise;
    const timezoneId = await timezoneIdPromise;
    const countryId = await countryIdPromise;

    await db
      .insertInto("user_data")
      .values({
        user_id: userId,
        birthdate: user.birthdate,
        last_name: user.lastName,
        timezone: timezoneId,
        first_name: user.firstName,
        description: user.description,
        origin_country: countryId,
      })
      .execute();
  }
}
\end{minted}

% Generated database types for type safety. I suggest taking one or two
% interfaces to explain the concept

\begin{minted}[linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{typescript}
/**
 * This file was generated by kysely-codegen.
 * Please do not edit it manually.
 */

import type { ColumnType } from "kysely";

export type Generated<T> = T extends ColumnType<infer S, infer I, infer U>
  ? ColumnType<S, I | undefined, U>
  : ColumnType<T, T | undefined, T>;

export type Numeric = ColumnType<string, number | string>;

export type Timestamp = ColumnType<Date, Date | string>;

export interface Countries {
  country: string;
  created_at: Generated<Timestamp>;
  id: Generated<number>;
  updated_at: Generated<Timestamp>;
}

export interface Languages {
  created_at: Generated<Timestamp>;
  id: Generated<number>;
  language: string;
  tsv: Generated<string | null>;
  updated_at: Generated<Timestamp>;
}

export interface Skills {
  category: string;
  created_at: Generated<Timestamp>;
  id: Generated<number>;
  skill: string;
  tsv: Generated<string | null>;
  updated_at: Generated<Timestamp>;
}

export interface Timezones {
  created_at: Generated<Timestamp>;
  id: Generated<number>;
  timezone: string;
  updated_at: Generated<Timestamp>;
}

export interface UserData {
  birthdate: Timestamp;
  created_at: Generated<Timestamp>;
  description: string;
  first_name: string;
  last_name: string;
  origin_country: Generated<number>;
  timezone: Generated<number>;
  tsv: Generated<string | null>;
  updated_at: Generated<Timestamp>;
  user_id: Generated<number>;
}

export interface UserLanguages {
  created_at: Generated<Timestamp>;
  language_id: Generated<number>;
  level: string;
  updated_at: Generated<Timestamp>;
  user_id: Generated<number>;
}

export interface UserPictures {
  blob: Buffer;
  created_at: Generated<Timestamp>;
  updated_at: Generated<Timestamp>;
  user_id: Generated<number>;
}

export interface Users {
  created_at: Generated<Timestamp>;
  email: string;
  id: Generated<number>;
  password: string;
  updated_at: Generated<Timestamp>;
}

export interface UserSkills {
  created_at: Generated<Timestamp>;
  description: string | null;
  price: Numeric | null;
  skill_id: Generated<number>;
  type: string;
  updated_at: Generated<Timestamp>;
  user_id: Generated<number>;
}

export interface DB {
  countries: Countries;
  languages: Languages;
  skills: Skills;
  timezones: Timezones;
  user_data: UserData;
  user_languages: UserLanguages;
  user_pictures: UserPictures;
  user_skills: UserSkills;
  users: Users;
}
\end{minted}

% Query builder. Pick one. I suggest keeping the user variable, if you pick a
% query that uses it

\begin{minted}[linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{typescript}
const availableCountries = await db
  .selectFrom("countries")
  .select(["id", "country"])
  .orderBy("country", "asc")
  .execute();

const availableTimezones = await db
  .selectFrom("timezones")
  .select(["id", "timezone"])
  .orderBy("timezone", "asc")
  .execute();

const availableLanguages = await db
  .selectFrom("languages")
  .select(["id", "language"])
  .orderBy("language", "asc")
  .execute();

const user = (await getServerSession(authOptions))!.user!;

const defaultValues = await db
  .selectFrom("users")
  .innerJoin("user_data", "user_data.user_id", "users.id")
  .select((eb) => [
    "user_data.first_name",
    "user_data.last_name",
    "user_data.birthdate",
    "user_data.origin_country",
    "user_data.description",
    jsonArrayFrom(
      eb
        .selectFrom("user_languages")
        .select(["language_id", "level"])
        .where("user_id", "=", user.id!),
    ).as("languages"),
  ])
  .where("users.id", "=", user.id!)
  .executeTakeFirstOrThrow();

const picture = await db
  .selectFrom("user_pictures")
  .where("user_id", "=", user.id)
  .executeTakeFirst();
\end{minted}
